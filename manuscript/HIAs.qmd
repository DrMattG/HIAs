---
title: Using spatially biased variables in ecosystem condition accounting with a GIS based workflow
subtitle: A Short Subtitle
author:
  - name: Anders Lorentzen Kolstad
    email: anders.kolstad@nina.no
    affiliations: 
        - id: some-tech
          name: Norwegian Institute for Nature Research
          department: Department of Terrestrial Ecology
          address: Street Address
          city: City
          state: State
          postal-code: Postal Code
    attributes:
        corresponding: true
    note: This is the first author footnote.
  - name: Bob Security
    email: bob@example.com
    affiliations:
        - id: another-u
          name: Another University
          department: Department Name
          address: Street Address
          city: City
          state: State
          postal-code: Postal Code
    note: |
      Another author footnote, this is a very long footnote and it should be a really long footnote. But this footnote is not yet sufficiently long enough to make two lines of footnote text.
  - name: Cat Memes
    email: cat@example.com
    affiliations:
        - ref: another-u
    note: Yet another author footnote.
  - name: Derek Zoolander
    email: derek@example.com
    affilations:
        - ref: some-tech
abstract: |
  This is the abstract. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum augue turpis, dictum non malesuada a, volutpat eget velit. Nam placerat turpis purus, eu tristique ex tincidunt et. Mauris sed augue eget turpis ultrices tincidunt. Sed et mi in leo porta egestas. Aliquam non laoreet velit. Nunc quis ex vitae eros aliquet auctor nec ac libero. Duis laoreet sapien eu mi luctus, in bibendum leo molestie. Sed hendrerit diam diam, ac dapibus nisl volutpat vitae. Aliquam bibendum varius libero, eu efficitur justo rutrum at. Sed at tempus elit.
keywords: 
  - SEEA EA
  - alien species
date: last-modified
bibliography: bibliography.bib
format:
  elsevier-pdf:
    keep-tex: true
    journal:
      name: Ecological Indicators
      formatting: preprint
      model: 3p
      cite-style: authoryear
    include-in-header:
      text: '\usepackage{lineno}\linenumbers'
editor: 
  markdown: 
    wrap: sentence
execute:
  echo: false
  include: false
  eval: false
  warning: false
  message: false
---

<!--# The document is set to eval=F in the yaml. This only affect the rendering, and not the interactive session. Eval is also set explicitly for each chunk. When eval is set to false it means the job is quite time consuming and I instead run it once and cache it locally.  -->



```{r setup}
#| warning: false
#| message: false
#| include: false
#| eval: true

library(tidyverse)
library(knitr)
library(sf)
library(tmap)
library(stars)
library(terra)
library(tidyterra)
library(ggtext)
library(cowplot)

myCRS <- 25832
```

```{r paths}
#| eval: true


# Conditional file directory
dir <- substr(getwd(), 1, 2)

# Some directories
mireFile <- "P:/41201785_okologisk_tilstand_2022_2023/data/Myrmodell/myrmodell90pros.tif"

path_infrastructure <- ifelse(dir == "C:",
  "R:/GeoSpatialData/Utility_governmentalServices/Norway_Infrastructure_Index/Original/Infrastrukturindeks_UTM33/infra_tiff.tif",
  "/data/R/GeoSpatialData/Utility_governmentalServices/Norway_Infrastructure_Index/Original/Infrastrukturindeks_UTM33/infra_tiff.tif"
)

path_naturetypes <- ifelse(dir == "C:",
  "R:/GeoSpatialData/Habitats_biotopes/Norway_Miljodirektoratet_Naturtyper_nin/Original/Naturtyper_nin_0000_norge_25833_FILEGDB/Naturtyper_nin_0000_norge_25833_FILEGDB.gdb",
  "/data/R/GeoSpatialData/Habitats_biotopes/Norway_Miljodirektoratet_Naturtyper_nin/Original/Naturtyper_nin_0000_norge_25833_FILEGDB/Naturtyper_nin_0000_norge_25833_FILEGDB.gdb"
)

path_muni <- paste0("../data/Basisdata_0000_Norge_25833_Kommuner_FGDB.gdb")

# path to local caching folder
path_temp <- ifelse(dir == "C:",
  "P:/41201785_okologisk_tilstand_2022_2023/data/cache/",
  "/data/P-Prosjekter2/41201785_okologisk_tilstand_2022_2023/data/cache/"
)
```

```{r getRelevantNTs}
#| eval: false


# I already did some work to identify the relevant nature types

# summary file (https://github.com/NINAnor/ecosystemCondition/blob/main/data/naturetypes/natureType_summary.rds)
naturetypes_summary <- readRDS("../data/natureType_summary.rds")

# Getting the nature types that have 7FA
myVars <- "7FA"

# naturetypes_summary2 <- naturetypes_summary %>%
#  rowwise() %>%
#  mutate(keepers = sum(c_across(
#    all_of(myVars))>0, na.rm=T)) %>%
#  filter(keepers >0,
#         Ecosystem == "våtmark") %>%
#  select(Nature_type, NiN_mainType, Year)
#
# naturetypes_summary2$Nature_type

# Getting the nature types that have the ADSV variables
myVars2 <- c("7TK", "7SE", "PRTK", "PRSL")
# naturetypes_summary3 <- naturetypes_summary %>%
#  rowwise() %>%
#  mutate(keepers = sum(c_across(
#    all_of(myVars2))>0, na.rm=T)) %>%
#  filter(keepers >0,
#         Ecosystem == "våtmark") %>%
#  select(Nature_type, NiN_mainType, Year)
#
# naturetypes_summary3$Nature_type
```

```{r relevantNTs}
#| eval: false

# These are the nature types I'm keeping for 7FA.
# Note the absence of ombrotriphic types
alienNTS <- c(
  "Slåttemyr",
  "Semi-naturlig våteng",
  "Rik åpen jordvannsmyr i mellomboreal sone",
  "Rik åpen sørlig jordvannsmyr",
  "Rik åpen jordvannsmyr i nordboreal og lavalpin sone"
)

# And these are the nature types that we use for the ADSV indicator
advsNTs <- c( # fens
  "Slåttemyr",
  "Sørlig slåttemyr",
  "Rik åpen jordvannsmyr i mellomboreal sone",
  "Rik åpen sørlig jordvannsmyr",
  "Semi-naturlig myr",
  "Rik åpen jordvannsmyr i nordboreal og lavalpin sone",
  # "Sørlig kaldkilde", # excluded springs

  # bogs (mainly)
  "Høgereligende og nordlig nedbørsmyr",
  "Øyblandingsmyr",
  "Konsentrisk høymyr",
  "Sørlig nedbørsmyr",
  "Atlantisk høymyr",
  "Terrengdekkende myr",
  "Eksentrisk høymyr",
  "Kanthøymyr",
  "Platåhøymyr",
  "Palsmyr"
)
```

```{r natureTypeData}
#| eval: false

# The data is too big to be stored on GitHub

# Impart polygon data set
naturetypes <- sf::st_read(dsn = path_naturetypes)
# 117k polygons (2023)
# sometimes this functin struggles with Norwegian letters.
# Restart R and try again.

naturetypes <- naturetypes |>
  # keep only wetlands and our selected nature types
  filter(
    hovedøkosystem == "våtmark",
    naturtype %in% c(advsNTs, alienNTS)
  ) |>
  # calculate the areas (m2) of the polygons
  mutate(area = SHAPE |> st_area()) |>
  # the variable codes and values are all in the same column
  separate_rows(ninBeskrivelsesvariable, sep = ",") |>
  separate(
    col = ninBeskrivelsesvariable,
    into = c("NiN_variable_code", "NiN_variable_value"),
    sep = "_",
    remove = F
  ) |>
  mutate(NiN_variable_value = as.numeric(NiN_variable_value)) |>
  filter(NiN_variable_code %in% c(myVars, myVars2)) |>
  select(
    id = identifikasjon_lokalId,
    municipality = kommunenummer,
    year = kartleggingsår,
    mosaic = mosaikk,
    quality = lokalitetskvalitet,
    biodiversity = naturmangfold,
    condition = tilstand,
    natureType = naturtype,
    variable = NiN_variable_code,
    value = NiN_variable_value,
    area
  ) |>
  st_transform(myCRS) # Chosing this to match the EDM (se further down)

# 13k obs.

naturetypes |>
  saveRDS("../data/surveyData.RDS")
# head(naturetypes)
```

```{r readSurvey}
#| eval: true

# read cached rds file. This is not so big.
naturetypes <- readRDS("../data/surveyData.RDS")
```

```{r getNorwayOutline}
#| eval: true

outline <- sf::read_sf("../data/outlineOfNorway_EPSG25833.shp") |>
  st_transform(myCRS)
```

```{r getMunicipalities}
#| eval: true

# Preparing the outlines for the three municipalieties

# find the correct layer
# st_layers(path_muni)

# read inn data and transform
muni <- sf::read_sf(path_muni, layer = "kommune") |>
  st_transform(myCRS)

# This returns some multisurfaces as well
# table(st_geometry_type(muni))
# function to make sure that multipolygons are returned
ensure_multipolygons <- function(X) {
  tmp1 <- tempfile(fileext = ".gpkg")
  tmp2 <- tempfile(fileext = ".gpkg")
  st_write(X, tmp1)
  gdalUtilities::ogr2ogr(tmp1, tmp2, f = "GPKG", nlt = "MULTIPOLYGON")
  Y <- st_read(tmp2)
  st_sf(st_drop_geometry(X), geom = st_geometry(Y))
}

muni <- ensure_multipolygons(muni)
# table(st_geometry_type(muni)) #OK

# subset of the three target municipalities
muni3 <- muni |>
  filter(kommunenummer %in% c(
    "3020", # Nordre Follo
    "5001", # Trondheim
    "5418" # Målselv
  )) |>
  mutate(Municipality = case_when(
    kommunenummer == "3020" ~ "Nordre Follo",
    kommunenummer == "5001" ~ "Trondheim",
    kommunenummer == "5418" ~ "Målselv"
  ))

# To crop EDM, I need the three municipalities seprately.
nf <- muni3 |>
  filter(kommunenummer == "3020")
tr <- muni3 |>
  filter(kommunenummer == "5001")
me <- muni3 |>
  filter(kommunenummer == "5418")
```

```{r prepPolygons}
#| eval: true

# I need to intersect the naturetypes data with the municipalities
nature3 <- naturetypes |>
  st_intersection(muni3)

nature3 |>
  as_tibble() |>
  count(municipality,
    sort = TRUE,
    name = "Number of polygons")

# and also to get the data coverage polygon.
# These I had to manually download from naturbase.no
dk <- read_sf("../data/dekningskartNF/Naturtyper NiN - Dekningskart.shp") |>
  rbind(read_sf("../data/dekningskartTR/Naturtyper NiN - Dekningskart.shp")) |>
  rbind(read_sf("../data/dekningskartME/Naturtyper NiN - Dekningskart.shp")) |>
  st_transform(st_crs(muni3)) |>
  st_intersection(muni3) |>
  st_union()
```

```{r prepSomeMoreMunicipalityShapes}
#| eval: true

# Simplified coastline / terrestrial area
terrestrial <- outline |>
  st_intersection(muni3)

# Polygons for the oceans in each municipality
ocean <- muni3 |>
  st_difference(outline)

# calculate stats - terrestrial area
terrestrial <- terrestrial |>
  mutate(
    area_t = geometry |> st_area(),
    t_area_km =
      round(units::drop_units(area_t * 1e-6))
  ) 
```

```{r positionMap}
#| eval: false

# Make map to show where the three municipalities are
# First, get centroids
centroids <- muni3 |>
  st_centroid()

(positionMap <- tm_shape(outline) +
  tm_polygons() +
  tm_shape(centroids) +
  tm_text(
    text = "Municipality",
    size = .8,
    xmod = 2,
    ymod = -1
  ) +
  tm_symbols(
    size = 1.5,
    shape = 17,
    col = "black"
  ) +
  tm_grid(projection = 4326) +
  tm_layout(
    bg.color = "skyblue",
    outer.margins = c(0.01, .02, .02, .02)))
```

```{r distanceBetweenMunis}
#| eval: true

# what is the distance between Nordre Follo and Målselv
(latlong <- centroids |>
  st_transform(4326) |>
st_coordinates() |>
  as_tibble())


km_distance <- centroids |>
  st_distance() |>
  max() |>
  set_units("km") |>
  drop_units() |>
  round()


round(max(latlong$Y)-min(latlong$Y), 1)


```


```{r mireDataTestCrop}
#| eval: false

# Testing the cropping proceedure using a downsampled starts object
mire_test <- read_stars(mireFile, proxy = T) |>
  setNames("mire") |>
  st_downsample(100) |>
  mutate(mire = na_if(mire, 0)) |>
  st_as_stars()

mire_test_nf <- mire_test |>
  st_crop(nf)

# The cropping is correct:
# tmap_mode("plot")
# tm_shape(mire_test)+
#  tm_raster(palette = "red")+
#  tm_shape(outline)+
#  tm_borders()+
#  tm_shape(mire_test_nf)+
#  tm_raster(col="red")

# Then we do the same, but without downsampling

mire_nf <- read_stars(mireFile, proxy = T) |>
  setNames("mire") |>
  # mutate(mire = na_if(mire, 0)) |>
  st_crop(nf) |>
  st_as_stars()
# The cropped raster is for some reason far into the ocean!

# The cells have values, so it seems like there is something
# that happens after the cropping
tmap_mode("plot")
tm_shape(mire_test) +
  tm_raster(palette = "red") +
  tm_shape(outline) +
  tm_borders() +
  tm_shape(mire_nf) +
  tm_raster(col = "red")
```

```{r mireTerra}
#| eval: false

# trying { terra } instead

# convert municipal outline to vect via st
nf_vect <- as(nf, "Spatial") |>
  terra::vect()

# crop and mask (very fast!)
mire_nf_terra <- terra::rast(mireFile) |>
  terra::crop(nf_vect) |>
  terra::mask(nf_vect)

# Plot to check overlap
# ggplot()+
#  geom_spatraster(data = mire_nf_terra)+
#  geom_spatvector(data = nf_vect,
#                  fill = NA)
# The cropping and masking worked.

# I like the stars, sf and tmap combo better, so I return to stars
mire_nf_stars <- mire_nf_terra |>
  st_as_stars()

ggplot() +
  geom_stars(data = mire_nf_stars) +
  coord_equal() +
  theme_void() +
  scale_fill_viridis_c()
```

```{r dk2-CoverageMaps}
#| eval: false

# calculate area of survey coverage maps
# values goes into summary table in the ms
dk2 <- read_sf("../data/dekningskartNF/Naturtyper NiN - Dekningskart.shp") |>
  rbind(read_sf("../data/dekningskartTR/Naturtyper NiN - Dekningskart.shp")) |>
  rbind(read_sf("../data/dekningskartME/Naturtyper NiN - Dekningskart.shp")) |>
  st_transform(st_crs(muni3)) |>
  st_intersection(muni3) |>
  st_cast("POLYGON") |>
  group_by(Municipality) |>
  summarise(geometry = st_union(geometry)) |>
  mutate(
    dk_area_km = geometry |> st_area(),
    dk_area_km = round(units::drop_units(dk_area_km * 1e-6))
  )
```

```{r mireArea}
#| eval: false

# calculate area of the mires in each municipality
# -- Nordre Follo
mireArea <- mire_nf_terra |>
  global(c("mean", "sum"), na.rm = T) |>
  add_column("Municipality" = "Nordre Follo") |>
  mutate(
    mirePercent = round(mean * 100, 1),
    mire_km2 = sum / 1e+4
  )

# Calculate the area of mire inside the coverage maps
# -- Nordre Follo
mire_nf_terra_dk <- mire_nf_terra |>
  terra::mask(dk2 |> filter(Municipality == "Nordre Follo")) |>
  global("sum", na.rm = T) |>
  mutate(mireInSurvey_km2 = sum / 1e+4) |>
  add_column(Municipality = "Nordre Follo")
```

```{r infrastructureIndex}
#| eval: false

# this data is on a 100x100m grid
infra <- stars::read_stars(path_infrastructure) |>
  # , which is mor then we need - warp it to 1x1km
  st_warp(
    cellsize = c(1000, 1000),
    crs = st_crs(nf),
    use_gdal = TRUE,
    method = "average"
  ) |>
  setNames("infrastructureIndex") |>
  st_transform(myCRS) |>
  mutate(infrastructureIndex = case_when(
    infrastructureIndex < 1 ~ 0,
    infrastructureIndex < 6 ~ 1,
    infrastructureIndex < 12 ~ 2,
    infrastructureIndex >= 12 ~ 3
  )) |>
  # takeing away point in the sea
  st_crop(outline)

# This step might seem rather stupid. We want to vectorize a rather large raster. This makes it a quite big data object. The reason is that there is no really good way to burn polygon data on to raster grid cells after the disuse of the raster package. It was not straight forward then either. But calculating intersections between polygons is very fast and easy.

infra <- eaTools::ea_homogeneous_area(infra,
  groups = infrastructureIndex
)



saveRDS(infra, paste0(path_temp, "infrastructureIndex_discrete_vectorized.rds"))
```

```{r readInfraStructureIndex}
#| eval: false

# read cached vetorized infrastructure data
infra <- readRDS(paste0(path_temp, "infrastructureIndex_discrete_vectorized.rds"))

# intersect with the three municipalities
# and calculate area
infraMuni3 <- infra |>
  st_intersection(muni3) |>
  mutate(area = geometry |> st_area())

# Turn m2 into km2
# and sum the total area per HIA
(infraMuni3_tbl <- infraMuni3 |>
  as.data.frame() |>
  mutate(area_HIA_km2 = units::drop_units(area) * 1e-6) |>
  group_by(Municipality, infrastructureIndex) |>
  summarise(total_area_HIAs_km2 = round(sum(area_HIA_km2))))

# Calculate the area weighted mean HIA value per municipality
infraMuni3_summary <- infraMuni3_tbl |>
  group_by(Municipality) |>
  summarise(
    meanHIA =
      round(
        weighted.mean(
          infrastructureIndex, total_area_HIAs_km2
        ), 2
      )
  )

# Make a plot to check that it has worked
infraMuni3_tbl |>
  ggplot() +
  geom_bar(
    aes(
      x = infrastructureIndex,
      y = total_area_HIAs_km2,
      fill = factor(infrastructureIndex),
      colour = factor(infrastructureIndex)
    ),
    stat = "identity",
    lwd = 1.2
  ) +
  scale_fill_manual(values = RColorBrewer::brewer.pal(4, "YlOrBr")) +
  scale_color_manual(values = RColorBrewer::brewer.pal(5, "YlOrBr")[-1]) +
  theme_minimal_hgrid() +
  labs(
    x = "Human Impact Area (HIA) class",
    y = "Area (km<sup>2</sup>)"
  ) +
  theme(
    axis.title.x = element_textbox_simple(
      width = NULL,
      padding = margin(4, 4, 4, 4),
      margin = margin(4, 0, 0, 0),
      linetype = 1,
      r = grid::unit(8, "pt"),
      fill = "azure1"
    ),
    axis.title.y = element_textbox_simple(
      width = NULL,
      padding = margin(4, 4, 4, 4),
      margin = margin(4, 0, 0, 0),
      linetype = 1,
      orientation = "left-rotated",
      r = grid::unit(8, "pt"),
      fill = "azure1"
    ),
    strip.background = element_blank(),
    strip.text = element_textbox(
      size = 12,
      color = "white", fill = "#5D729D", box.color = "#4A618C",
      halign = 0.5, linetype = 1, r = unit(5, "pt"), width = unit(1, "npc"),
      padding = margin(2, 0, 1, 0), margin = margin(3, 3, 3, 3)
    )
  ) +
  guides(fill = "none", colour = "none") +
  scale_y_log10() +
  facet_grid(cols = vars(Municipality)) 
```

<!--# Need to update this figure -->

```{r infraMuniMaps}
#| eval: false

# Infratructure in each municipality
infraMuniMap <- tm_shape(muni3) +
  tm_borders() +
  tm_shape(infraMuni3) +
  tm_polygons(
    col = "infrastructureIndex",
    style = "cat",
    title = "Human Impact\nArea Class"
  ) +
  tm_shape(muni3) +
  tm_borders(lwd = 3, col = "black") +
  tm_facets(by = "Municipality") +
  tm_layout(
    legend.show = FALSE,
    panel.label.height = 0)

# A figure with just the legend
infraMuniMap_l <- tm_shape(muni3) +
  tm_borders() +
  tm_shape(infraMuni3) +
  tm_polygons(
    col = "infrastructureIndex",
    style = "cat",
    title = "Human Impact\nArea Class"
  ) +
  tm_layout(legend.only = TRUE,
            legend.position = c("left", "bottom"),
            legend.outside = TRUE)



# Syrvey coverage and other colour overlayed the municipalities
muniPlot <- tm_shape(muni3) +
  tm_borders() +
  tm_facets(
    by = "Municipality",
    ncol = 3
  ) +
  tm_shape(terrestrial) +
  tm_fill(
    col = "lightgreen",
    alpha = .4
  ) +
  tm_shape(ocean) +
  tm_polygons(
    col = "skyblue",
    border.col = "black"
  ) +
  tm_shape(dk) +
  tm_polygons(
    col = "grey",
    alpha = .8
  ) +
  tm_shape(nature3) +
  tm_polygons(
    col = "red",
    border.col = "red",
    lwd = 3
  )


(methodsMap <- tmap_arrange(
  positionMap,
  muniPlot,
  infraMuniMap_l,
  infraMuniMap,
  widths = c(.35, .65),
  heights = c(.6, .4),
  outer.margins = NULL
))


# tmap_save(methodsMap, "../figures/studyLocations.tiff",
#           dpi= 1000,
#           units = "cm",
#           width = 18,
#           height = 10)
#
# saveRDS(methodsMap, "../figures/studyLocation.RDS")
```


```{r muni-tbl}
#| eval: false

# Calulate some more stats for the table with municipality stats

# Number of mire polygons per municipality
# -- Try count() here instead
nature3_tbl <- nature3 |>
  group_by(Municipality) |>
  summarise(n = n()) |>
  as_tibble()

# Take muni3 and add all sorts of other data to it
# using left_join.
# Save local cached file
muni_tbl <- muni3 |>
  # calculate total area
  mutate(
    area_km =
      round(
        units::drop_units(
          geom |> st_area() * 1e-6
        )
      )
  ) |>
  # make tibble for the coming join
  as_tibble() |>
  # paste inn terrestrial area
  left_join(terrestrial |>
              as_tibble() |> 
              select(kommunenummer, t_area_km),
    keep = F
  ) |>
  # area of survey
  left_join(dk2 |> select(Municipality, dk_area_km)) |>
  mutate(dk_percent = round((dk_area_km / t_area_km) * 100)) |>
  # number of polygons
  left_join(nature3_tbl |> select(Municipality, n)) |>
  # total mire area and %
  left_join(mireArea |> select(Municipality, mirePercent, mire_km2)) |>
  # % mire inside survey coverage map
  left_join(mire_nf_terra_dk |> select(Municipality, mireInSurvey_km2)) |>
  mutate(mireInSurvery_percent = round(mireInSurvey_km2 / mire_km2 * 100, 2)) |>
  left_join(infraMuni3_summary)

saveRDS(muni_tbl, "../data/municipality_stats.RDS")
```

```{r read-munitbl}
#| eval: true
muni_tbl <- readRDS("../data/municipality_stats.RDS")
```

# Introduction

Ecosystem condition accounting is the game of compiling relevant data on the status, trends and qualities of ecosystems (i.e. nature) and communicating this in a structured format.
Its purpose is to make it easier to account for nature in policy by making the environmental costs of certain policies and practices visible to decision makers.
As natural capital keeps declining all over the world, it is becoming increasingly urgent to make the message clear to decision makers about.
A statistical standard for ecosystem accounting, including ecosystem condition accounting, was developed by the UN and adopted by the UN Statistical Commission in 2021 and is called SEEA EA (@unitednations2021; System of Environmental-Economic Accounting - Ecosystem Accounting).
The standard, or framework, is a set of rules, principles and best practices for compiling Ecosystem accounts, mainly aimed at national accounts.

Central to ecosystem condition accounts are variables and indicators.
These are parameters chosen to reflect the central condition characteristics of the ecosystems, and that can be quantified and ideally monitored over time to reflect the status and trends in condition.
Indicators are (data) variables that are normalised (rescaled) against upper and lower reference values to become bound between the values 0 and 1.
This normalisation ensures that indicators are more comparable because an indicator value of 1 will mean the same for all indicators, i.e. that the variable equals the upper reference value which again reflect the value of the variables under the reference condition.
Similarly, a value of 0 mean that the variable is the worst possible state.
The reference condition needs to be defined for each Ecosystem Condition Assessment separately, but SEEA EA gives some suggestion, such as an an ecosystem with no or minimal anthropogenic disturbance.

A general requirement for indicators in the SEEA EA framework is that they should give an unbiased representation of the condition inside the ecosystem assets [@czucz_selection_2021, table 1; see also @unitednations2021 §2.87] Ecosystem assets are defined as "ecological entities \[meaning areas\] about which information is sought and about which statistics are ultimately compiled [@unitednations2021]. This requirement for indicator validity means that spatially biased data are ill suited, especially if sampling intensity varies along gradient of anthropogenic pressures and hence ecosystem condition. SEEA EA is spatially explicit, which in practice means that indicators that are in some way sampled (i.e. not complete wall-to-wall data like remotely sensed imagery), the values are projected on to areas on the map, so that all areas inside the ecosystem accounting area get assigned value for that indicator. There are at least 3 general ways to achieve this complete areal coverage of indicator values:

a.  Using wall-to-wall data (e.g. remotely sensed data)
b.  Predict values using a model (e.g. by accounting for environmental variation)
c.  Simple projection of some best estimate, typically a central tendency from area representative data

The need for an unbiased estimation of indicator values is unquestionable, but nonetheless, this requirement puts a large limitation on what types of data one can use.
Ecosystem condition assessments are generally limited by data availability, and the choice of variables and indicators to include in assessments are more often or not a pragmatic and opportunistic one which is unlikely to reflect the full scope of the ecosystem condition characteristics.
Note that the same is true for thematic biases.
For example reflected in the scarcity of data included on insects or soil biota, even though most will agree they represent key ecosystem characteristics.
Also having data from only one or a subset of nature types inside what is defined as the ecosystem in the assessment, is a typical thematic bias in ecosystem accounting.
However, in this paper we chose to focus on spatial bias.

Being able to make use of spatially biased data would greatly alleviate data shortage problems in ecosystem condition accounts.
One way to achieve this is modelling (option b in the list above).
Models can describe the general associations between the spatially sampled data and the context (e.g. the set of environmental variables) where it was samples, and use these relationships to predict and project indicator values to areas that where not originally sampled.
Depending on the data that goes into these models, they can be very reliable and make good indicators.
This is especially true when the ecosystem assets are large (e.g. regions or nations).
But when they are small, like the scale of a municipality, and when the indicator is more likely to be used as the evidence base in concrete physical land use planning, then the inherent level of uncertainty from such models becomes unacceptable.

In this study we explore the potential for using a stratified aggregation technique to make use of spatially biased field data in ecosystem condition accounting.
We demonstrate this technique using a generic GIS-based workflow for compiling ecosystem condition accounts that can be applied at any spatial scale, and we highlight the opportunities for local use-cases of this workflow by contrasting our findings across four neighboring municipalities in Norway.
The main question is how much generalisation can we perform on the data we have before the resulting indicator looses its practical value in local governance processes.
We end by interviewing end-users from the relevant municipalities about the perceived benefits and shortcomings of our condition indicators.

# Material and Methods

In this study we focused on open mire ecosystems in Norway.
For this ecosystem we have an ecosystem delineation map produced using remotely sensed data and a deep learning model [@bakkestuen_delineation_2023].
This model, which has a 90.9% precision when tested against independent field data, estimates 12.7% of the area in southern Norway is mire [@bakkestuen_delineation_2023].
Mires are ecologically and socially important in Norway simply doe to its large extent, and due to its role in climate mitigation, as mires store a large amount of carbon (REF?).
There has not been a national assessment of the ecosystem condition of mires in Norway, but we recent contributed on a report which presented several new indicators that can be used in future assessment [@nybo_indikatorer_2023; see also @kolstad2023]).
This study builds on the work in that report.

We started by defining the reference state as one where ecosystems are subject to little or no human influence, with a climate as in the period 1961-1990 and a native species pool similar as today (i.e no mammoths allowed).
We then identified two *ecosystem condition characteristics* that, along with many other characteristics that we do not specify here, define the typical behavior of open mire ecosystems in the reference condition: species composition, and; vegetation intactness.

To describe these two characteristics we use five condition variables from the same data set ( @tbl-variables).
The data set is from a standardised field survey of nature types in Norway that started in 2018 and which is still ongoing.
The data is freely available [@norwegian_environmental_agency_naturtyper_2024].
See @miljødirektoratet for the sampling protocol (in Norwegian).
We included data from 2018 to 2023.
In this survey, selected nature types are delineated on a map, and each locality is scored on a range of variables relevant for describing the state and quality of nature.
The surveys are commissioned with the goal of producing data relevant for immediate land-use decisions, and is therefore spatially biased, typically towards areas with high human impact or expected impact.
In addition there is a thematic and size bias in the sampling protocol.
Of all possible mire types, the survey only maps the following:

-   Southern ombrotrophic mires \> 2500 m^2^

-   Northern ombrotrophic mires \> 10.000 m^2^

-   All semi-natural mires (minerotrophic fens)

-   Calcareous southern fens \>500 m^2^

-   Calcareous northern fens \>1000 m^2^

In the above, *southern* refers to boreonemoral and southboreal zones, and *northern* refers to mid-boreal, north boreal, and alpine zones @asbjørnmoen1998 .
In addition, the northern fens need to be even more calcareous than the southern fens in order to be surveyed, and the variable 7FK is not recorded in ombrotrophic mires.
In this paper we assume the survey is representative for the entire mire ecosystem in Norway.
Although it is possible that smaller or less calcareous mires will score systematically different than the ones that are surveyed we do not think this is the case for our variables at least.
It may also be that alien plants are more or less common on bogs relative to fens.
For this we have no assumption.

| Variable code        | Variable name                                    | Measurement unit                                                                        | Description                                                                                                    | Reference                          |
|-------------|-------------|---------------|--------------------|-------------|
| 7FK                  | Prevalence of alien species                      | Unitless, ordinal, non-linear scale from 1 (no alien species) to 7 (only alien species) | The fraction of the species composition made up from alien species                                             | @runehalvorsen2019                 |
| 7SE                  | Human caused abration or abration-caused erosion | Unitless, ordinal, non-linear scale from 1 to 4.                                        | Measures the frequency of imagined 4 m^2^ quadrats layed over the area that has some sign of abration          | @runehalvorsen2019                 |
| PRSL                 | *as above*                                       | Unitless, ordinal, non-linear scale from 0 to 7.                                        | Same as 7SE, but recorded at a higher resolution                                                               | @miljødirektoratet                 |
| 7TK                  | Tracks from large vehicles                       | Unitless, ordinal, non-linear scale from 1 to 4.                                        | Measures the frequency of imagined 100 m^2^ quadrats layed over the area that has some signs of vehicle tracks | @rune_halvorsen_dokumentasjon_2019 |
| PRTK                 | *as above*                                       | Unitless, ordinal, non-linear scale from 0 to 7.                                        | Same as 7TK, but recorded at a higher resolution                                                               | @miljødirektoratet                 |
| Infrastructure Index | Infrastructure Index                             | Unitelss linear scale from 0 to 13.2                                                    | Unitelss index ranging from from 0 to 13.2                                                                     | @erikstad_index_2023               |
| HIA                  | Human Impact area                                | Ordinal, non-linear scale from 1 to 4                                                   | A categorical representation of the infrastructure index                                                       | this paper                         |

: Variables used in this study {#tbl-variables}

7FK was developed into a single indicator (i.e. a normalised variable) named *Alien plant cover*.
Variables 2-5 describe very related aspects and so they where combined into one indicator called antropogenic disturbance to soil and vegetation, or ADSV for short.
This was done by taking the value from the variable with the lowest value, i.e. worst condition.
For both indicators, the lower and upper reference values, i.e. the worst and best possible condition that the variables can be in, is given by the range of the data where 0 or 1 is the lower limit and 4, 7 or 8 is the upper limit, depending on the variable (see @tbl-variables).
See @fig-workflow for a schematic workflow for the indicator development.

The Alien plant cover was assigned to ECT class B1 - Compositional state characteristics, and ADSV was assigned to ECT class A1 - Physical state characteristics [@czucz_common_2021].

![Schematic workflow followed in this paper. Sub-index A is calculated using spatially explicit aggregation (i.e .a simple overlay taking the mean value).](../images/workflow.jpg){#fig-workflow}

We chose three municipalities in Norway to test out the indicators (@fig-studyLocation).
These municipalities are spread over `r round(max(latlong$Y)-min(latlong$Y), 1)` degrees latitude, or `r km_distance` km, and also differ in the amount of mire area, the total area surveyed, and the prevalence of infrastructure (@tbl-variables).

```{r fig-studyLocation}
#| eval: true
#| include: true
#| out.width: '100%'
#| fig.cap:
#| - "Postion of the three example municipalities in
#| Norway. For each municipality the map shows ocean in blue and non-ocean
#| in green. The survey coverage maps are in grey, and the mapped mires are
#| in red, with polygon borderes made extra thich to make them visible,
#| but then also exagerating their size."

(temp <- readRDS("../figures/studyLocation.RDS"))
```

| Municipality | Total terrestrial area (km^2^)                                            | \% of terrestrial area surveyed                                            | \% open mires in relation to total terrestrial area                         | Total mire area (km^2^)                                                  | %of mire area inside survey area                                                      | Number of mire polygons in survey                                 | Mean Infrastructure Index value                                         |
|---------|---------|---------|---------|---------|---------|---------|---------|
| Nordre Follo | `r muni_tbl |> filter(Municipality == "Nordre Follo") |> pull(t_area_km)` | `r muni_tbl |> filter(Municipality == "Nordre Follo") |> pull(dk_percent)` | `r muni_tbl |> filter(Municipality == "Nordre Follo") |> pull(mirePercent)` | `r muni_tbl |> filter(Municipality == "Nordre Follo") |> pull(mire_km2)` | `r muni_tbl |> filter(Municipality == "Nordre Follo") |> pull(mireInSurvery_percent)` | `r muni_tbl |> filter(Municipality == "Nordre Follo") |> pull(n)` | `r muni_tbl |> filter(Municipality == "Nordre Follo") |> pull(meanHIA)` |
| Trondheim    | `r muni_tbl |> filter(Municipality == "Trondheim") |> pull(t_area_km)`    | `r muni_tbl |> filter(Municipality == "Trondheim") |> pull(dk_percent)`    |                                                                             |                                                                          |                                                                                       | `r muni_tbl |> filter(Municipality == "Trondheim") |> pull(n)`    | `r muni_tbl |> filter(Municipality == "Trondheim") |> pull(meanHIA)`    |
| Målselv      | `r muni_tbl |> filter(Municipality == "Målselv") |> pull(t_area_km)`      | `r muni_tbl |> filter(Municipality == "Målselv") |> pull(dk_percent)`      |                                                                             |                                                                          |                                                                                       | `r muni_tbl |> filter(Municipality == "Målselv") |> pull(n)`      | `r muni_tbl |> filter(Municipality == "Målselv") |> pull(meanHIA)`      |

: Information for the three target municipalities in Norway

Validation/sensitivity analyses (varying HIA resolution and minimum *n*?)

Aggregation

# Results

Data availability/coverage

Validation

National/regional indicator - do we have enough data?

Municipal case study

# Discussion

# Conclusion

# Credit authorship contribution statement {.unnumbered}

# Declaration of Competing Interest {.unnumbered}

# Acknowledgements {.unnumbered}

# Data availability {.unnumbered}

# References {.unnumbered}
